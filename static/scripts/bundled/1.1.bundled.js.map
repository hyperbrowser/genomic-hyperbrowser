{"version":3,"sources":["webpack:///1.1.bundled.js","webpack:///./galaxy/scripts/mvc/dataset/data.js?f841","webpack:///./galaxy/scripts/mvc/ui/icon-button.js?40a6"],"names":["webpackJsonp","16","module","exports","__webpack_require__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","Backbone","_","$","Modal","Frames","mod_icon_btn","DatasetMetadata","Model","extend","Dataset","defaults","id","type","name","hda_ldda","metadata","initialize","this","get","_set_metadata","on","each","keys","attributes","k","indexOf","new_key","split","set","silent","get_metadata","attribute","urlRoot","Galaxy","root","TabularDataset","prototype","chunk_url","first_data_chunk","offset","at_eof","options","call","url_viz","get_next_chunk","self","next_chunk","Deferred","getJSON","success","chunk","rval","ck_data","resolve","DatasetCollection","Collection","model","TabularDatasetChunkedView","View","row_count","loading_chunk","TabularButtonTracksterView","$el","expand_to_container","height","scroll_elt","attempt_to_fetch","func","scrolled_to_bottom","loading_indicator","show","when","then","result","_renderChunk","hide","render","attr","append","data_table","cellpadding","column_names","header_container","appendTo","header_row","join","j","first_chunk","scroll","_renderCell","cell_contents","index","colspan","$cell","text","column_types","undefined","addClass","length","_renderRow","line","cells","row","num_columns","slice","range","find","TopLevelTabularDatasetChunkedView","parents","p","css","window","scrollTop","EmbeddedTabularDatasetChunkedView","position","overflow","innerHeight","el","scrollHeight","col","chrom","start","end","dataset_id","genome_build","file_ext","search","str","array","match","parent","modal","frame","console","log","btn_viz","IconButtonView","IconButton","title","icon_class","setElement","events","mouseover tr","mouseleave","e","is_numeric","n","isNaN","parseFloat","isFinite","target","children","eq","html","btn_viz_pars","gene_region","left","top","off","click","add","url","param","createTabularDatasetChunkedView","dataset_config","parent_elt","embedded","view","apply","21","on_click","menu_options","is_menu_button","href","enabled","visible","tooltip_config","placement","bind","tooltip","new_elem","template","toJSON","replaceWith","event","isFunction","buffer","IconButtonCollection","IconButtonMenuView","tagName","collection","button","elt","make_popupmenu","create_icon_buttons_menu","config","global_config","buttons","map","button_config"],"mappings":"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","file":"1.1.bundled.js","sourcesContent":["webpackJsonp([1],{\n\n/***/ 16:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(Backbone, _, $) {// Additional dependencies: jQuery, underscore.\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(8), __webpack_require__(48), __webpack_require__(21)], __WEBPACK_AMD_DEFINE_RESULT__ = function (Modal, Frames, mod_icon_btn) {\n\t\n\t    /**\n\t     * Dataset metedata.\n\t     */\n\t    var DatasetMetadata = Backbone.Model.extend({});\n\t\n\t    /**\n\t     * A dataset. In Galaxy, datasets are associated with a history, so\n\t     * this object is also known as a HistoryDatasetAssociation.\n\t     */\n\t    var Dataset = Backbone.Model.extend({\n\t        defaults: {\n\t            id: '',\n\t            type: '',\n\t            name: '',\n\t            hda_ldda: 'hda',\n\t            metadata: null\n\t        },\n\t\n\t        initialize: function () {\n\t            // Metadata can be passed in as a model or a set of attributes; if it's\n\t            // already a model, there's no need to set metadata.\n\t            if (!this.get('metadata')) {\n\t                this._set_metadata();\n\t            }\n\t\n\t            // Update metadata on change.\n\t            this.on('change', this._set_metadata, this);\n\t        },\n\t\n\t        _set_metadata: function () {\n\t            var metadata = new DatasetMetadata();\n\t\n\t            // Move metadata from dataset attributes to metadata object.\n\t            _.each(_.keys(this.attributes), function (k) {\n\t                if (k.indexOf('metadata_') === 0) {\n\t                    // Found metadata.\n\t                    var new_key = k.split('metadata_')[1];\n\t                    metadata.set(new_key, this.attributes[k]);\n\t                    delete this.attributes[k];\n\t                }\n\t            }, this);\n\t\n\t            // Because this is an internal change, silence it.\n\t            this.set('metadata', metadata, { 'silent': true });\n\t        },\n\t\n\t        /**\n\t         * Returns dataset metadata for a given attribute.\n\t         */\n\t        get_metadata: function (attribute) {\n\t            return this.attributes.metadata.get(attribute);\n\t        },\n\t\n\t        urlRoot: Galaxy.root + \"api/datasets\"\n\t    });\n\t\n\t    /**\n\t     * A tabular dataset. This object extends dataset to provide incremental chunked data.\n\t     */\n\t    var TabularDataset = Dataset.extend({\n\t        defaults: _.extend({}, Dataset.prototype.defaults, {\n\t            chunk_url: null,\n\t            first_data_chunk: null,\n\t            offset: 0,\n\t            at_eof: false\n\t        }),\n\t\n\t        initialize: function (options) {\n\t            Dataset.prototype.initialize.call(this);\n\t\n\t            // If first data chunk is available, next chunk is 1.\n\t            if (this.attributes.first_data_chunk) {\n\t                this.attributes.offset = this.attributes.first_data_chunk.offset;\n\t            }\n\t            this.attributes.chunk_url = Galaxy.root + 'dataset/display?dataset_id=' + this.id;\n\t            this.attributes.url_viz = Galaxy.root + 'visualization';\n\t        },\n\t\n\t        /**\n\t         * Returns a jQuery Deferred object that resolves to the next data chunk or null if at EOF.\n\t         */\n\t        get_next_chunk: function () {\n\t            // If already at end of file, do nothing.\n\t            if (this.attributes.at_eof) {\n\t                return null;\n\t            }\n\t\n\t            // Get next chunk.\n\t            var self = this,\n\t                next_chunk = $.Deferred();\n\t            $.getJSON(this.attributes.chunk_url, {\n\t                offset: self.attributes.offset\n\t            }).success(function (chunk) {\n\t                var rval;\n\t                if (chunk.ck_data !== '') {\n\t                    // Found chunk.\n\t                    rval = chunk;\n\t                    self.attributes.offset = chunk.offset;\n\t                } else {\n\t                    // At EOF.\n\t                    self.attributes.at_eof = true;\n\t                    rval = null;\n\t                }\n\t                next_chunk.resolve(rval);\n\t            });\n\t\n\t            return next_chunk;\n\t        }\n\t    });\n\t\n\t    var DatasetCollection = Backbone.Collection.extend({\n\t        model: Dataset\n\t    });\n\t\n\t    /**\n\t     * Provides a base for table-based, dynamic view of a tabular dataset.\n\t     * Do not instantiate directly; use either TopLevelTabularDatasetChunkedView\n\t     * or EmbeddedTabularDatasetChunkedView.\n\t     */\n\t    var TabularDatasetChunkedView = Backbone.View.extend({\n\t\n\t        /**\n\t         * Initialize view and, importantly, set a scroll element.\n\t         */\n\t        initialize: function (options) {\n\t            // Row count for rendering.\n\t            this.row_count = 0;\n\t            this.loading_chunk = false;\n\t\n\t            // load trackster button\n\t            new TabularButtonTracksterView({\n\t                model: options.model,\n\t                $el: this.$el\n\t            });\n\t        },\n\t\n\t        expand_to_container: function () {\n\t            if (this.$el.height() < this.scroll_elt.height()) {\n\t                this.attempt_to_fetch();\n\t            }\n\t        },\n\t\n\t        attempt_to_fetch: function (func) {\n\t            var self = this;\n\t            if (!this.loading_chunk && this.scrolled_to_bottom()) {\n\t                this.loading_chunk = true;\n\t                this.loading_indicator.show();\n\t                $.when(self.model.get_next_chunk()).then(function (result) {\n\t                    if (result) {\n\t                        self._renderChunk(result);\n\t                        self.loading_chunk = false;\n\t                    }\n\t                    self.loading_indicator.hide();\n\t                    self.expand_to_container();\n\t                });\n\t            }\n\t        },\n\t\n\t        render: function () {\n\t            // Add loading indicator.\n\t            this.loading_indicator = $('<div/>').attr('id', 'loading_indicator');\n\t            this.$el.append(this.loading_indicator);\n\t\n\t            // Add data table and header.\n\t            var data_table = $('<table/>').attr({\n\t                id: 'content_table',\n\t                cellpadding: 0\n\t            });\n\t            this.$el.append(data_table);\n\t            var column_names = this.model.get_metadata('column_names'),\n\t                header_container = $('<thead/>').appendTo(data_table),\n\t                header_row = $('<tr/>').appendTo(header_container);\n\t            if (column_names) {\n\t                header_row.append('<th>' + column_names.join('</th><th>') + '</th>');\n\t            } else {\n\t                for (var j = 1; j <= this.model.get_metadata('columns'); j++) {\n\t                    header_row.append('<th>' + j + '</th>');\n\t                }\n\t            }\n\t\n\t            // Render first chunk.\n\t            var self = this,\n\t                first_chunk = this.model.get('first_data_chunk');\n\t            if (first_chunk) {\n\t                // First chunk is bootstrapped, so render now.\n\t                this._renderChunk(first_chunk);\n\t            } else {\n\t                // No bootstrapping, so get first chunk and then render.\n\t                $.when(self.model.get_next_chunk()).then(function (result) {\n\t                    self._renderChunk(result);\n\t                });\n\t            }\n\t\n\t            // -- Show new chunks during scrolling. --\n\t\n\t            // Set up chunk loading when scrolling using the scrolling element.\n\t            this.scroll_elt.scroll(function () {\n\t                self.attempt_to_fetch();\n\t            });\n\t        },\n\t\n\t        /**\n\t         * Returns true if user has scrolled to the bottom of the view.\n\t         */\n\t        scrolled_to_bottom: function () {\n\t            return false;\n\t        },\n\t\n\t        // -- Helper functions. --\n\t\n\t        _renderCell: function (cell_contents, index, colspan) {\n\t            var $cell = $('<td>').text(cell_contents);\n\t            var column_types = this.model.get_metadata('column_types');\n\t            if (colspan !== undefined) {\n\t                $cell.attr('colspan', colspan).addClass('stringalign');\n\t            } else if (column_types) {\n\t                if (index < column_types.length) {\n\t                    if (column_types[index] === 'str' || column_types[index] === 'list') {\n\t                        /* Left align all str columns, right align the rest */\n\t                        $cell.addClass('stringalign');\n\t                    }\n\t                }\n\t            }\n\t            return $cell;\n\t        },\n\t\n\t        _renderRow: function (line) {\n\t            // Check length of cells to ensure this is a complete row.\n\t            var cells = line.split('\\t'),\n\t                row = $('<tr>'),\n\t                num_columns = this.model.get_metadata('columns');\n\t\n\t            if (this.row_count % 2 !== 0) {\n\t                row.addClass('dark_row');\n\t            }\n\t\n\t            if (cells.length === num_columns) {\n\t                _.each(cells, function (cell_contents, index) {\n\t                    row.append(this._renderCell(cell_contents, index));\n\t                }, this);\n\t            } else if (cells.length > num_columns) {\n\t                // SAM file or like format with optional metadata included.\n\t                _.each(cells.slice(0, num_columns - 1), function (cell_contents, index) {\n\t                    row.append(this._renderCell(cell_contents, index));\n\t                }, this);\n\t                row.append(this._renderCell(cells.slice(num_columns - 1).join('\\t'), num_columns - 1));\n\t            } else if (cells.length === 1) {\n\t                // Comment line, just return the one cell.\n\t                row.append(this._renderCell(line, 0, num_columns));\n\t            } else {\n\t                // cells.length is greater than one, but less than num_columns.  Render cells and pad tds.\n\t                // Possibly a SAM file or like format with optional metadata missing.\n\t                // Could also be a tabular file with a line with missing columns.\n\t                _.each(cells, function (cell_contents, index) {\n\t                    row.append(this._renderCell(cell_contents, index));\n\t                }, this);\n\t                _.each(_.range(num_columns - cells.length), function () {\n\t                    row.append($('<td>'));\n\t                });\n\t            }\n\t\n\t            this.row_count++;\n\t            return row;\n\t        },\n\t\n\t        _renderChunk: function (chunk) {\n\t            var data_table = this.$el.find('table');\n\t            _.each(chunk.ck_data.split('\\n'), function (line, index) {\n\t                if (line !== '') {\n\t                    data_table.append(this._renderRow(line));\n\t                }\n\t            }, this);\n\t        }\n\t    });\n\t\n\t    /**\n\t     * Tabular view that is placed at the top level of page. Scrolling occurs\n\t     * view top-level elements outside of view.\n\t     */\n\t    var TopLevelTabularDatasetChunkedView = TabularDatasetChunkedView.extend({\n\t\n\t        initialize: function (options) {\n\t            TabularDatasetChunkedView.prototype.initialize.call(this, options);\n\t\n\t            // Scrolling happens in top-level elements.\n\t            var scroll_elt = _.find(this.$el.parents(), function (p) {\n\t                return $(p).css('overflow') === 'auto';\n\t            });\n\t\n\t            // If no scrolling element found, use window.\n\t            if (!scroll_elt) {\n\t                scroll_elt = window;\n\t            }\n\t\n\t            // Wrap scrolling element for easy access.\n\t            this.scroll_elt = $(scroll_elt);\n\t        },\n\t\n\t        /**\n\t         * Returns true if user has scrolled to the bottom of the view.\n\t         */\n\t        scrolled_to_bottom: function () {\n\t            return this.$el.height() - this.scroll_elt.scrollTop() - this.scroll_elt.height() <= 0;\n\t        }\n\t\n\t    });\n\t\n\t    /**\n\t     * Tabular view tnat is embedded in a page. Scrolling occurs in view's el.\n\t     */\n\t    var EmbeddedTabularDatasetChunkedView = TabularDatasetChunkedView.extend({\n\t\n\t        initialize: function (options) {\n\t            TabularDatasetChunkedView.prototype.initialize.call(this, options);\n\t\n\t            // Because view is embedded, set up div to do scrolling.\n\t            this.scroll_elt = this.$el.css({\n\t                position: 'relative',\n\t                overflow: 'scroll',\n\t                height: options.height || '500px'\n\t            });\n\t        },\n\t\n\t        /**\n\t         * Returns true if user has scrolled to the bottom of the view.\n\t         */\n\t        scrolled_to_bottom: function () {\n\t            return this.$el.scrollTop() + this.$el.innerHeight() >= this.el.scrollHeight;\n\t        }\n\t\n\t    });\n\t\n\t    /** Button for trackster visualization */\n\t    var TabularButtonTracksterView = Backbone.View.extend({\n\t\n\t        // gene region columns\n\t        col: {\n\t            chrom: null,\n\t            start: null,\n\t            end: null\n\t        },\n\t\n\t        // url for trackster\n\t        url_viz: null,\n\t\n\t        // dataset id\n\t        dataset_id: null,\n\t\n\t        // database key\n\t        genome_build: null,\n\t\n\t        // data type\n\t        file_ext: null,\n\t\n\t        // backbone initialize\n\t        initialize: function (options) {\n\t            // check if environment is available\n\t            var Galaxy = parent.Galaxy;\n\t\n\t            // link galaxy modal or create one\n\t            if (Galaxy && Galaxy.modal) {\n\t                this.modal = Galaxy.modal;\n\t            }\n\t\n\t            // link galaxy frames\n\t            if (Galaxy && Galaxy.frame) {\n\t                this.frame = Galaxy.frame;\n\t            }\n\t\n\t            // check\n\t            if (!this.modal || !this.frame) {\n\t                return;\n\t            }\n\t\n\t            // model/metadata\n\t            var model = options.model;\n\t            var metadata = model.get('metadata');\n\t\n\t            // check for datatype\n\t            if (!model.get('file_ext')) {\n\t                return;\n\t            }\n\t\n\t            // get data type\n\t            this.file_ext = model.get('file_ext');\n\t\n\t            // check for bed-file format\n\t            if (this.file_ext == 'bed') {\n\t                // verify that metadata exists\n\t                if (metadata.get('chromCol') && metadata.get('startCol') && metadata.get('endCol')) {\n\t                    // read in columns\n\t                    this.col.chrom = metadata.get('chromCol') - 1;\n\t                    this.col.start = metadata.get('startCol') - 1;\n\t                    this.col.end = metadata.get('endCol') - 1;\n\t                } else {\n\t                    console.log('TabularButtonTrackster : Bed-file metadata incomplete.');\n\t                    return;\n\t                }\n\t            }\n\t\n\t            // check for vcf-file format\n\t            if (this.file_ext == 'vcf') {\n\t                // search array\n\t                function search(str, array) {\n\t                    for (var j = 0; j < array.length; j++) if (array[j].match(str)) return j;\n\t                    return -1;\n\t                };\n\t\n\t                // load\n\t                this.col.chrom = search('Chrom', metadata.get('column_names'));\n\t                this.col.start = search('Pos', metadata.get('column_names'));\n\t                this.col.end = null;\n\t\n\t                // verify that metadata exists\n\t                if (this.col.chrom == -1 || this.col.start == -1) {\n\t                    console.log('TabularButtonTrackster : VCF-file metadata incomplete.');\n\t                    return;\n\t                }\n\t            }\n\t\n\t            // check\n\t            if (this.col.chrom === undefined) {\n\t                return;\n\t            }\n\t\n\t            // get dataset id\n\t            if (model.id) {\n\t                this.dataset_id = model.id;\n\t            } else {\n\t                console.log('TabularButtonTrackster : Dataset identification is missing.');\n\t                return;\n\t            }\n\t\n\t            // get url\n\t            if (model.get('url_viz')) {\n\t                this.url_viz = model.get('url_viz');\n\t            } else {\n\t                console.log('TabularButtonTrackster : Url for visualization controller is missing.');\n\t                return;\n\t            }\n\t\n\t            // get genome_build / database key\n\t            if (model.get('genome_build')) {\n\t                this.genome_build = model.get('genome_build');\n\t            }\n\t\n\t            // create the icon\n\t            var btn_viz = new mod_icon_btn.IconButtonView({\n\t                model: new mod_icon_btn.IconButton({\n\t                    title: 'Visualize',\n\t                    icon_class: 'chart_curve',\n\t                    id: 'btn_viz'\n\t                })\n\t            });\n\t\n\t            // set element\n\t            this.setElement(options.$el);\n\t\n\t            // add to element\n\t            this.$el.append(btn_viz.render().$el);\n\t\n\t            // hide the button\n\t            this.hide();\n\t        },\n\t\n\t        /** Add event handlers */\n\t        events: {\n\t            'mouseover tr': 'show',\n\t            'mouseleave': 'hide'\n\t        },\n\t\n\t        // show button\n\t        show: function (e) {\n\t            var self = this;\n\t\n\t            // is numeric\n\t            function is_numeric(n) {\n\t                return !isNaN(parseFloat(n)) && isFinite(n);\n\t            };\n\t\n\t            // check\n\t            if (this.col.chrom === null) return;\n\t\n\t            // get selected data line\n\t            var row = $(e.target).parent();\n\t\n\t            // verify that location has been found\n\t            var chrom = row.children().eq(this.col.chrom).html();\n\t            var start = row.children().eq(this.col.start).html();\n\t\n\t            // end is optional\n\t            var end = this.col.end ? row.children().eq(this.col.end).html() : start;\n\t\n\t            // double check location\n\t            if (!chrom.match(\"^#\") && chrom !== \"\" && is_numeric(start)) {\n\t\n\t                // get target gene region\n\t                var btn_viz_pars = {\n\t                    dataset_id: this.dataset_id,\n\t                    gene_region: chrom + \":\" + start + \"-\" + end\n\t                };\n\t\n\t                // get button position\n\t                var offset = row.offset();\n\t                var left = offset.left - 10;\n\t                var top = offset.top - $(window).scrollTop() + 3;\n\t\n\t                // update css\n\t                $('#btn_viz').css({ 'position': 'fixed', 'top': top + 'px', 'left': left + 'px' });\n\t                $('#btn_viz').off('click');\n\t                $('#btn_viz').click(function () {\n\t                    self.frame.add({\n\t                        title: 'Trackster',\n\t                        url: self.url_viz + '/trackster?' + $.param(btn_viz_pars)\n\t                    });\n\t                });\n\t\n\t                // show the button\n\t                $('#btn_viz').show();\n\t            } else {\n\t                // hide the button\n\t                $('#btn_viz').hide();\n\t            }\n\t        },\n\t\n\t        /** hide button */\n\t        hide: function () {\n\t            this.$('#btn_viz').hide();\n\t        }\n\t    });\n\t\n\t    // -- Utility functions. --\n\t\n\t    /**\n\t     * Create a model, attach it to a view, render view, and attach it to a parent element.\n\t     */\n\t    var createModelAndView = function (model, view, model_config, parent_elt) {\n\t        // Create model, view.\n\t        var a_view = new view({\n\t            model: new model(model_config)\n\t        });\n\t\n\t        // Render view and add to parent element.\n\t        a_view.render();\n\t        if (parent_elt) {\n\t            parent_elt.append(a_view.$el);\n\t        }\n\t\n\t        return a_view;\n\t    };\n\t\n\t    /**\n\t     * Create a tabular dataset chunked view (and requisite tabular dataset model)\n\t     * and appends to parent_elt.\n\t     */\n\t    var createTabularDatasetChunkedView = function (options) {\n\t        // If no model, create and set model from dataset config.\n\t        if (!options.model) {\n\t            options.model = new TabularDataset(options.dataset_config);\n\t        }\n\t\n\t        var parent_elt = options.parent_elt;\n\t        var embedded = options.embedded;\n\t\n\t        // Clean up options so that only needed options are passed to view.\n\t        delete options.embedded;\n\t        delete options.parent_elt;\n\t        delete options.dataset_config;\n\t\n\t        // Create and set up view.\n\t        var view = embedded ? new EmbeddedTabularDatasetChunkedView(options) : new TopLevelTabularDatasetChunkedView(options);\n\t        view.render();\n\t\n\t        if (parent_elt) {\n\t            parent_elt.append(view.$el);\n\t            // If we're sticking this in another element, once it's appended check\n\t            // to make sure we've filled enough space.\n\t            // Without this, the scroll elements don't work.\n\t            view.expand_to_container();\n\t        }\n\t\n\t        return view;\n\t    };\n\t\n\t    return {\n\t        Dataset: Dataset,\n\t        TabularDataset: TabularDataset,\n\t        DatasetCollection: DatasetCollection,\n\t        TabularDatasetChunkedView: TabularDatasetChunkedView,\n\t        createTabularDatasetChunkedView: createTabularDatasetChunkedView\n\t    };\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2), __webpack_require__(3), __webpack_require__(1)))\n\n/***/ }),\n\n/***/ 21:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(Backbone, _, $) {!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n\t    //jquery\n\t    //backbone\n\t], __WEBPACK_AMD_DEFINE_RESULT__ = function () {\n\t    //=============================================================================\n\t    /**\n\t     * backbone model for icon buttons\n\t     */\n\t    var IconButton = Backbone.Model.extend({\n\t        defaults: {\n\t            title: \"\",\n\t            icon_class: \"\",\n\t            on_click: null,\n\t            menu_options: null,\n\t            is_menu_button: true,\n\t            id: null,\n\t            href: null,\n\t            target: null,\n\t            enabled: true,\n\t            visible: true,\n\t            tooltip_config: {}\n\t        }\n\t    });\n\t\n\t    /**\n\t     *  backbone view for icon buttons\n\t     */\n\t    var IconButtonView = Backbone.View.extend({\n\t\n\t        initialize: function () {\n\t            // better rendering this way\n\t            this.model.attributes.tooltip_config = { placement: 'bottom' };\n\t            this.model.bind('change', this.render, this);\n\t        },\n\t\n\t        render: function () {\n\t            // hide tooltip\n\t            this.$el.tooltip('hide');\n\t\n\t            var new_elem = this.template(this.model.toJSON());\n\t            // configure tooltip\n\t            new_elem.tooltip(this.model.get('tooltip_config'));\n\t            this.$el.replaceWith(new_elem);\n\t            this.setElement(new_elem);\n\t            return this;\n\t        },\n\t\n\t        events: {\n\t            'click': 'click'\n\t        },\n\t\n\t        click: function (event) {\n\t            // if on_click pass to that function\n\t            if (_.isFunction(this.model.get('on_click'))) {\n\t                this.model.get('on_click')(event);\n\t                return false;\n\t            }\n\t            // otherwise, bubble up ( to href or whatever )\n\t            return true;\n\t        },\n\t\n\t        // generate html element\n\t        template: function (options) {\n\t            var buffer = 'title=\"' + options.title + '\" class=\"icon-button';\n\t\n\t            if (options.is_menu_button) {\n\t                buffer += ' menu-button';\n\t            }\n\t\n\t            buffer += ' ' + options.icon_class;\n\t\n\t            if (!options.enabled) {\n\t                buffer += '_disabled';\n\t            }\n\t\n\t            // close class tag\n\t            buffer += '\"';\n\t\n\t            if (options.id) {\n\t                buffer += ' id=\"' + options.id + '\"';\n\t            }\n\t\n\t            buffer += ' href=\"' + options.href + '\"';\n\t            // add target for href\n\t            if (options.target) {\n\t                buffer += ' target=\"' + options.target + '\"';\n\t            }\n\t            // set visibility\n\t            if (!options.visible) {\n\t                buffer += ' style=\"display: none;\"';\n\t            }\n\t\n\t            // enabled/disabled\n\t            if (options.enabled) {\n\t                buffer = '<a ' + buffer + '/>';\n\t            } else {\n\t                buffer = '<span ' + buffer + '/>';\n\t            }\n\t\n\t            // return element\n\t            return $(buffer);\n\t        }\n\t    });\n\t\n\t    // define collection\n\t    var IconButtonCollection = Backbone.Collection.extend({\n\t        model: IconButton\n\t    });\n\t\n\t    /**\n\t     * menu with multiple icon buttons\n\t     * views are not needed nor used for individual buttons\n\t     */\n\t    var IconButtonMenuView = Backbone.View.extend({\n\t\n\t        tagName: 'div',\n\t\n\t        initialize: function () {\n\t            this.render();\n\t        },\n\t\n\t        render: function () {\n\t            // initialize icon buttons\n\t            var self = this;\n\t            this.collection.each(function (button) {\n\t                // create and add icon button to menu\n\t                var elt = $('<a/>').attr('href', 'javascript:void(0)').attr('title', button.attributes.title).addClass('icon-button menu-button').addClass(button.attributes.icon_class).appendTo(self.$el).click(button.attributes.on_click);\n\t\n\t                // configure tooltip\n\t                if (button.attributes.tooltip_config) {\n\t                    elt.tooltip(button.attributes.tooltip_config);\n\t                }\n\t\n\t                // add popup menu to icon\n\t                var menu_options = button.get('options');\n\t                if (menu_options) {\n\t                    make_popupmenu(elt, menu_options);\n\t                }\n\t            });\n\t\n\t            // return\n\t            return this;\n\t        }\n\t    });\n\t\n\t    /**\n\t     * Returns an IconButtonMenuView for the provided configuration.\n\t     * Configuration is a list of dictionaries where each dictionary\n\t     * defines an icon button. Each dictionary must have the following\n\t     * elements: icon_class, title, and on_click.\n\t     */\n\t    var create_icon_buttons_menu = function (config, global_config) {\n\t        // initialize global configuration\n\t        if (!global_config) global_config = {};\n\t\n\t        // create and initialize menu\n\t        var buttons = new IconButtonCollection(_.map(config, function (button_config) {\n\t            return new IconButton(_.extend(button_config, global_config));\n\t        }));\n\t\n\t        // return menu\n\t        return new IconButtonMenuView({ collection: buttons });\n\t    };\n\t\n\t    //=============================================================================\n\t    return {\n\t        IconButton: IconButton,\n\t        IconButtonView: IconButtonView,\n\t        IconButtonCollection: IconButtonCollection,\n\t        IconButtonMenuView: IconButtonMenuView,\n\t        create_icon_buttons_menu: create_icon_buttons_menu\n\t    };\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2), __webpack_require__(3), __webpack_require__(1)))\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// 1.1.bundled.js","// Additional dependencies: jQuery, underscore.\ndefine(['mvc/ui/ui-modal', 'mvc/ui/ui-frames', 'mvc/ui/icon-button'], function(Modal, Frames, mod_icon_btn) {\n\n/**\n * Dataset metedata.\n */\nvar DatasetMetadata = Backbone.Model.extend({});\n\n/**\n * A dataset. In Galaxy, datasets are associated with a history, so\n * this object is also known as a HistoryDatasetAssociation.\n */\nvar Dataset = Backbone.Model.extend({\n    defaults: {\n        id: '',\n        type: '',\n        name: '',\n        hda_ldda: 'hda',\n        metadata: null\n    },\n\n    initialize: function() {\n        // Metadata can be passed in as a model or a set of attributes; if it's\n        // already a model, there's no need to set metadata.\n        if (!this.get('metadata')) {\n            this._set_metadata();\n        }\n\n        // Update metadata on change.\n        this.on('change', this._set_metadata, this);\n    },\n\n    _set_metadata: function() {\n        var metadata = new DatasetMetadata();\n\n        // Move metadata from dataset attributes to metadata object.\n        _.each(_.keys(this.attributes), function(k) {\n            if (k.indexOf('metadata_') === 0) {\n                // Found metadata.\n                var new_key = k.split('metadata_')[1];\n                metadata.set(new_key, this.attributes[k]);\n                delete this.attributes[k];\n            }\n        }, this);\n\n        // Because this is an internal change, silence it.\n        this.set('metadata', metadata, { 'silent': true });\n    },\n\n    /**\n     * Returns dataset metadata for a given attribute.\n     */\n    get_metadata: function(attribute) {\n        return this.attributes.metadata.get(attribute);\n    },\n\n    urlRoot: Galaxy.root + \"api/datasets\"\n});\n\n/**\n * A tabular dataset. This object extends dataset to provide incremental chunked data.\n */\nvar TabularDataset = Dataset.extend({\n    defaults: _.extend({}, Dataset.prototype.defaults, {\n        chunk_url: null,\n        first_data_chunk: null,\n        offset: 0,\n        at_eof: false\n    }),\n\n    initialize: function(options) {\n        Dataset.prototype.initialize.call(this);\n\n        // If first data chunk is available, next chunk is 1.\n        if (this.attributes.first_data_chunk){\n            this.attributes.offset = this.attributes.first_data_chunk.offset;\n        }\n        this.attributes.chunk_url = Galaxy.root + 'dataset/display?dataset_id=' + this.id;\n        this.attributes.url_viz = Galaxy.root + 'visualization';\n    },\n\n    /**\n     * Returns a jQuery Deferred object that resolves to the next data chunk or null if at EOF.\n     */\n    get_next_chunk: function() {\n        // If already at end of file, do nothing.\n        if (this.attributes.at_eof) {\n            return null;\n        }\n\n        // Get next chunk.\n        var self = this,\n            next_chunk = $.Deferred();\n        $.getJSON(this.attributes.chunk_url, {\n            offset: self.attributes.offset\n        }).success(function(chunk) {\n            var rval;\n            if (chunk.ck_data !== '') {\n                // Found chunk.\n                rval = chunk;\n                self.attributes.offset = chunk.offset;\n            }\n            else {\n                // At EOF.\n                self.attributes.at_eof = true;\n                rval = null;\n            }\n            next_chunk.resolve(rval);\n        });\n\n        return next_chunk;\n    }\n});\n\nvar DatasetCollection = Backbone.Collection.extend({\n    model: Dataset\n});\n\n/**\n * Provides a base for table-based, dynamic view of a tabular dataset.\n * Do not instantiate directly; use either TopLevelTabularDatasetChunkedView\n * or EmbeddedTabularDatasetChunkedView.\n */\nvar TabularDatasetChunkedView = Backbone.View.extend({\n\n    /**\n     * Initialize view and, importantly, set a scroll element.\n     */\n    initialize: function(options) {\n        // Row count for rendering.\n        this.row_count = 0;\n        this.loading_chunk = false;\n\n        // load trackster button\n        new TabularButtonTracksterView({\n            model   : options.model,\n            $el     : this.$el\n        });\n    },\n\n    expand_to_container: function(){\n        if (this.$el.height() < this.scroll_elt.height()){\n            this.attempt_to_fetch();\n        }\n    },\n\n    attempt_to_fetch: function( func ){\n        var self = this;\n        if ( !this.loading_chunk && this.scrolled_to_bottom() ) {\n            this.loading_chunk = true;\n            this.loading_indicator.show();\n            $.when(self.model.get_next_chunk()).then(function(result) {\n                if (result) {\n                    self._renderChunk(result);\n                    self.loading_chunk = false;\n                }\n                self.loading_indicator.hide();\n                self.expand_to_container();\n            });\n        }\n    },\n\n    render: function() {\n        // Add loading indicator.\n        this.loading_indicator = $('<div/>').attr('id', 'loading_indicator');\n        this.$el.append(this.loading_indicator);\n\n        // Add data table and header.\n        var data_table = $('<table/>').attr({\n            id: 'content_table',\n            cellpadding: 0\n        });\n        this.$el.append(data_table);\n        var column_names = this.model.get_metadata('column_names'),\n            header_container = $('<thead/>').appendTo(data_table),\n            header_row = $('<tr/>').appendTo(header_container);\n        if (column_names) {\n            header_row.append('<th>' + column_names.join('</th><th>') + '</th>');\n        } else {\n            for (var j = 1; j <= this.model.get_metadata('columns'); j++) {\n                header_row.append('<th>' + j + '</th>');\n            }\n        }\n\n        // Render first chunk.\n        var self = this,\n            first_chunk = this.model.get('first_data_chunk');\n        if (first_chunk) {\n            // First chunk is bootstrapped, so render now.\n            this._renderChunk(first_chunk);\n        }\n        else {\n            // No bootstrapping, so get first chunk and then render.\n            $.when(self.model.get_next_chunk()).then(function(result) {\n                self._renderChunk(result);\n            });\n        }\n\n        // -- Show new chunks during scrolling. --\n\n        // Set up chunk loading when scrolling using the scrolling element.\n        this.scroll_elt.scroll(function(){\n            self.attempt_to_fetch();\n        });\n    },\n\n    /**\n     * Returns true if user has scrolled to the bottom of the view.\n     */\n    scrolled_to_bottom: function() {\n        return false;\n    },\n\n    // -- Helper functions. --\n\n    _renderCell: function(cell_contents, index, colspan) {\n        var $cell = $('<td>').text(cell_contents);\n        var column_types = this.model.get_metadata('column_types');\n        if (colspan !== undefined) {\n            $cell.attr('colspan', colspan).addClass('stringalign');\n        } else if (column_types) {\n            if (index < column_types.length) {\n                if (column_types[index] === 'str' || column_types[index] === 'list') {\n                    /* Left align all str columns, right align the rest */\n                    $cell.addClass('stringalign');\n                }\n            }\n        }\n        return $cell;\n    },\n\n    _renderRow: function(line) {\n        // Check length of cells to ensure this is a complete row.\n        var cells = line.split('\\t'),\n            row = $('<tr>'),\n            num_columns = this.model.get_metadata('columns');\n\n        if (this.row_count % 2 !== 0) {\n            row.addClass('dark_row');\n        }\n\n        if (cells.length === num_columns) {\n            _.each(cells, function(cell_contents, index) {\n                row.append(this._renderCell(cell_contents, index));\n            }, this);\n        }\n        else if (cells.length > num_columns) {\n            // SAM file or like format with optional metadata included.\n            _.each(cells.slice(0, num_columns - 1), function(cell_contents, index) {\n                row.append(this._renderCell(cell_contents, index));\n            }, this);\n            row.append(this._renderCell(cells.slice(num_columns - 1).join('\\t'), num_columns - 1));\n        }\n        else if (cells.length === 1){\n            // Comment line, just return the one cell.\n            row.append(this._renderCell(line, 0, num_columns));\n        }\n        else {\n            // cells.length is greater than one, but less than num_columns.  Render cells and pad tds.\n            // Possibly a SAM file or like format with optional metadata missing.\n            // Could also be a tabular file with a line with missing columns.\n            _.each(cells, function(cell_contents, index) {\n                row.append(this._renderCell(cell_contents, index));\n            }, this);\n            _.each(_.range(num_columns - cells.length), function(){\n                row.append($('<td>'));\n            });\n        }\n\n        this.row_count++;\n        return row;\n    },\n\n    _renderChunk: function(chunk) {\n        var data_table = this.$el.find('table');\n        _.each(chunk.ck_data.split('\\n'), function(line, index) {\n            if (line !== ''){\n                data_table.append(this._renderRow(line));\n            }\n        }, this);\n    }\n});\n\n/**\n * Tabular view that is placed at the top level of page. Scrolling occurs\n * view top-level elements outside of view.\n */\nvar TopLevelTabularDatasetChunkedView = TabularDatasetChunkedView.extend({\n\n    initialize: function(options) {\n        TabularDatasetChunkedView.prototype.initialize.call(this, options);\n\n        // Scrolling happens in top-level elements.\n        var scroll_elt = _.find(this.$el.parents(), function(p) {\n            return $(p).css('overflow') === 'auto';\n        });\n\n        // If no scrolling element found, use window.\n        if (!scroll_elt) { scroll_elt = window; }\n\n        // Wrap scrolling element for easy access.\n        this.scroll_elt = $(scroll_elt);\n    },\n\n    /**\n     * Returns true if user has scrolled to the bottom of the view.\n     */\n    scrolled_to_bottom: function() {\n        return (this.$el.height() - this.scroll_elt.scrollTop() - this.scroll_elt.height() <= 0);\n    }\n\n});\n\n/**\n * Tabular view tnat is embedded in a page. Scrolling occurs in view's el.\n */\nvar EmbeddedTabularDatasetChunkedView = TabularDatasetChunkedView.extend({\n\n    initialize: function(options) {\n        TabularDatasetChunkedView.prototype.initialize.call(this, options);\n\n        // Because view is embedded, set up div to do scrolling.\n        this.scroll_elt = this.$el.css({\n            position: 'relative',\n            overflow: 'scroll',\n            height: options.height || '500px'\n        });\n    },\n\n    /**\n     * Returns true if user has scrolled to the bottom of the view.\n     */\n    scrolled_to_bottom: function() {\n        return this.$el.scrollTop() + this.$el.innerHeight() >= this.el.scrollHeight;\n    }\n\n});\n\n/** Button for trackster visualization */\nvar TabularButtonTracksterView = Backbone.View.extend({\n\n    // gene region columns\n    col: {\n        chrom   : null,\n        start   : null,\n        end     : null\n    },\n\n    // url for trackster\n    url_viz     : null,\n\n    // dataset id\n    dataset_id  : null,\n\n    // database key\n    genome_build: null,\n\n    // data type\n    file_ext   : null,\n\n    // backbone initialize\n    initialize: function (options) {\n        // check if environment is available\n        var Galaxy = parent.Galaxy;\n\n        // link galaxy modal or create one\n        if (Galaxy && Galaxy.modal) {\n            this.modal = Galaxy.modal;\n        }\n\n        // link galaxy frames\n        if (Galaxy && Galaxy.frame) {\n            this.frame = Galaxy.frame;\n        }\n\n        // check\n        if (!this.modal || !this.frame) {\n            return;\n        }\n\n        // model/metadata\n        var model       = options.model;\n        var metadata    = model.get('metadata');\n\n        // check for datatype\n        if (!model.get('file_ext')) {\n            return;\n        }\n\n        // get data type\n        this.file_ext = model.get('file_ext');\n\n        // check for bed-file format\n        if (this.file_ext == 'bed') {\n            // verify that metadata exists\n            if (metadata.get('chromCol') && metadata.get('startCol') && metadata.get('endCol')) {\n                // read in columns\n                this.col.chrom   = metadata.get('chromCol') - 1;\n                this.col.start   = metadata.get('startCol') - 1;\n                this.col.end     = metadata.get('endCol') - 1;\n            } else {\n                console.log('TabularButtonTrackster : Bed-file metadata incomplete.');\n                return;\n            }\n        }\n\n        // check for vcf-file format\n        if (this.file_ext == 'vcf') {\n            // search array\n            function search (str, array) {\n                for (var j = 0; j < array.length; j++)\n                    if (array[j].match(str)) return j;\n                return -1;\n            };\n\n            // load\n            this.col.chrom = search('Chrom', metadata.get('column_names'));\n            this.col.start = search('Pos', metadata.get('column_names'));\n            this.col.end   = null;\n\n            // verify that metadata exists\n            if (this.col.chrom == -1 || this.col.start == -1) {\n                console.log('TabularButtonTrackster : VCF-file metadata incomplete.');\n                return;\n            }\n        }\n\n        // check\n        if(this.col.chrom === undefined) {\n            return;\n        }\n\n        // get dataset id\n        if (model.id) {\n            this.dataset_id = model.id;\n        } else {\n            console.log('TabularButtonTrackster : Dataset identification is missing.');\n            return;\n        }\n\n        // get url\n        if (model.get('url_viz')) {\n            this.url_viz = model.get('url_viz');\n        } else {\n            console.log('TabularButtonTrackster : Url for visualization controller is missing.');\n            return;\n        }\n\n        // get genome_build / database key\n        if (model.get('genome_build')) {\n            this.genome_build = model.get('genome_build');\n        }\n\n        // create the icon\n        var btn_viz = new mod_icon_btn.IconButtonView({\n            model : new mod_icon_btn.IconButton({\n                title       : 'Visualize',\n                icon_class  : 'chart_curve',\n                id          : 'btn_viz'\n            })\n        });\n\n        // set element\n        this.setElement(options.$el);\n\n        // add to element\n        this.$el.append(btn_viz.render().$el);\n\n        // hide the button\n        this.hide();\n    },\n\n    /** Add event handlers */\n    events: {\n        'mouseover tr'  : 'show',\n        'mouseleave'    : 'hide'\n    },\n\n    // show button\n    show: function (e) {\n        var self = this;\n\n        // is numeric\n        function is_numeric(n) {\n            return !isNaN(parseFloat(n)) && isFinite(n);\n        };\n\n        // check\n        if(this.col.chrom === null)\n            return;\n\n        // get selected data line\n        var row = $(e.target).parent();\n\n        // verify that location has been found\n        var chrom = row.children().eq(this.col.chrom).html();\n        var start = row.children().eq(this.col.start).html();\n\n        // end is optional\n        var end = this.col.end ? row.children().eq(this.col.end).html() : start;\n\n        // double check location\n        if (!chrom.match(\"^#\") && chrom !== \"\" && is_numeric(start)) {\n\n            // get target gene region\n            var btn_viz_pars = {\n                dataset_id  : this.dataset_id,\n                gene_region : chrom + \":\" + start + \"-\" + end\n            };\n\n            // get button position\n            var offset  = row.offset();\n            var left    = offset.left - 10;\n            var top     = offset.top - $(window).scrollTop() + 3;\n\n            // update css\n            $('#btn_viz').css({'position': 'fixed', 'top': top + 'px', 'left': left + 'px'});\n            $('#btn_viz').off('click');\n            $('#btn_viz').click( function() {\n                self.frame.add({\n                    title   : 'Trackster',\n                    url     : self.url_viz + '/trackster?' + $.param(btn_viz_pars)\n                });\n            });\n\n            // show the button\n            $('#btn_viz').show();\n        } else {\n            // hide the button\n            $('#btn_viz').hide();\n        }\n    },\n\n    /** hide button */\n    hide: function () {\n        this.$('#btn_viz').hide();\n    }\n});\n\n// -- Utility functions. --\n\n/**\n * Create a model, attach it to a view, render view, and attach it to a parent element.\n */\nvar createModelAndView = function(model, view, model_config, parent_elt) {\n    // Create model, view.\n    var a_view = new view({\n        model: new model(model_config)\n    });\n\n    // Render view and add to parent element.\n    a_view.render();\n    if (parent_elt) {\n        parent_elt.append(a_view.$el);\n    }\n\n    return a_view;\n};\n\n/**\n * Create a tabular dataset chunked view (and requisite tabular dataset model)\n * and appends to parent_elt.\n */\nvar createTabularDatasetChunkedView = function(options) {\n    // If no model, create and set model from dataset config.\n    if (!options.model) {\n        options.model = new TabularDataset(options.dataset_config);\n    }\n\n    var parent_elt = options.parent_elt;\n    var embedded = options.embedded;\n\n    // Clean up options so that only needed options are passed to view.\n    delete options.embedded;\n    delete options.parent_elt;\n    delete options.dataset_config;\n\n    // Create and set up view.\n    var view = (embedded ? new EmbeddedTabularDatasetChunkedView(options) :\n                           new TopLevelTabularDatasetChunkedView(options));\n    view.render();\n\n    if (parent_elt) {\n        parent_elt.append(view.$el);\n        // If we're sticking this in another element, once it's appended check\n        // to make sure we've filled enough space.\n        // Without this, the scroll elements don't work.\n        view.expand_to_container();\n    }\n\n    return view;\n};\n\nreturn {\n    Dataset: Dataset,\n    TabularDataset: TabularDataset,\n    DatasetCollection: DatasetCollection,\n    TabularDatasetChunkedView: TabularDatasetChunkedView,\n    createTabularDatasetChunkedView: createTabularDatasetChunkedView\n};\n\n});\n\n\n\n// WEBPACK FOOTER //\n// ./galaxy/scripts/mvc/dataset/data.js","define([\n    //jquery\n    //backbone\n], function(){\n//=============================================================================\n/**\n * backbone model for icon buttons\n */\nvar IconButton = Backbone.Model.extend({\n    defaults: {\n        title           : \"\",\n        icon_class      : \"\",\n        on_click        : null,\n        menu_options    : null,\n        is_menu_button  : true,\n        id              : null,\n        href            : null,\n        target          : null,\n        enabled         : true,\n        visible         : true,\n        tooltip_config  : {}\n    }\n});\n\n/**\n *  backbone view for icon buttons\n */\nvar IconButtonView = Backbone.View.extend({\n\n    initialize : function(){\n        // better rendering this way\n        this.model.attributes.tooltip_config = { placement : 'bottom' };\n        this.model.bind( 'change', this.render, this );\n    },\n\n    render : function( ){\n        // hide tooltip\n        this.$el.tooltip( 'hide' );\n\n        var new_elem = this.template( this.model.toJSON() );\n        // configure tooltip\n        new_elem.tooltip( this.model.get( 'tooltip_config' ));\n        this.$el.replaceWith( new_elem );\n        this.setElement( new_elem );\n        return this;\n    },\n\n    events : {\n        'click' : 'click'\n    },\n\n    click : function( event ){\n        // if on_click pass to that function\n        if( _.isFunction( this.model.get( 'on_click' ) ) ){\n            this.model.get( 'on_click' )( event );\n            return false;\n        }\n        // otherwise, bubble up ( to href or whatever )\n        return true;\n    },\n\n    // generate html element\n    template: function( options ){\n        var buffer = 'title=\"' + options.title + '\" class=\"icon-button';\n\n        if( options.is_menu_button ){\n            buffer += ' menu-button';\n        }\n\n        buffer += ' ' + options.icon_class;\n\n        if( !options.enabled ){\n            buffer += '_disabled';\n        }\n\n        // close class tag\n        buffer += '\"';\n\n        if( options.id ){\n            buffer += ' id=\"' + options.id + '\"';\n        }\n\n        buffer += ' href=\"' + options.href + '\"';\n        // add target for href\n        if( options.target ){\n            buffer += ' target=\"' + options.target + '\"';\n        }\n        // set visibility\n        if( !options.visible ){\n            buffer += ' style=\"display: none;\"';\n        }\n\n        // enabled/disabled\n        if ( options.enabled ){\n            buffer = '<a ' + buffer + '/>';\n        } else {\n            buffer = '<span ' + buffer + '/>';\n        }\n\n        // return element\n        return $( buffer );\n    }\n} );\n\n// define collection\nvar IconButtonCollection = Backbone.Collection.extend({\n    model: IconButton\n});\n\n/**\n * menu with multiple icon buttons\n * views are not needed nor used for individual buttons\n */\nvar IconButtonMenuView = Backbone.View.extend({\n\n    tagName: 'div',\n\n    initialize: function(){\n        this.render();\n    },\n\n    render: function(){\n        // initialize icon buttons\n        var self = this;\n        this.collection.each(function(button){\n            // create and add icon button to menu\n            var elt = $('<a/>')\n                .attr('href', 'javascript:void(0)')\n                .attr('title', button.attributes.title)\n                .addClass('icon-button menu-button')\n                .addClass(button.attributes.icon_class)\n                .appendTo(self.$el)\n                .click(button.attributes.on_click);\n\n            // configure tooltip\n            if (button.attributes.tooltip_config){\n                elt.tooltip(button.attributes.tooltip_config);\n            }\n\n            // add popup menu to icon\n            var menu_options = button.get('options');\n            if (menu_options){\n                make_popupmenu(elt, menu_options);\n            }\n        });\n\n        // return\n        return this;\n    }\n});\n\n/**\n * Returns an IconButtonMenuView for the provided configuration.\n * Configuration is a list of dictionaries where each dictionary\n * defines an icon button. Each dictionary must have the following\n * elements: icon_class, title, and on_click.\n */\nvar create_icon_buttons_menu = function(config, global_config)\n{\n    // initialize global configuration\n    if (!global_config) global_config = {};\n\n    // create and initialize menu\n    var buttons = new IconButtonCollection(\n        _.map(config, function(button_config){\n            return new IconButton(_.extend(button_config, global_config));\n        })\n    );\n\n    // return menu\n    return new IconButtonMenuView( {collection: buttons} );\n};\n\n\n//=============================================================================\n    return {\n        IconButton              : IconButton,\n        IconButtonView          : IconButtonView,\n        IconButtonCollection    : IconButtonCollection,\n        IconButtonMenuView      : IconButtonMenuView,\n        create_icon_buttons_menu: create_icon_buttons_menu\n    };\n})\n\n\n\n// WEBPACK FOOTER //\n// ./galaxy/scripts/mvc/ui/icon-button.js"],"sourceRoot":""}